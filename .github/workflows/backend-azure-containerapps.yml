name: Deploy API (Azure Container Apps)

permissions:
  contents: read
  id-token: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

on:
  push:
    branches: [ main ]
    paths:
      - 'Backend/**'
      - '.github/workflows/backend-azure-containerapps.yml'
  workflow_dispatch:
    inputs:
      run_migrations:
        description: "Run Alembic upgrade head after deploy (true/false)"
        required: false
        default: 'false'
      health_retry_seconds:
        description: "Max seconds to wait for /health/ready=200"
        required: false
        default: '90'

env:
  AZURE_RESOURCE_GROUP: SMB-Loyalty-Group
  CONTAINERAPP_NAME: apismbloyaltyapp
  ACR_NAME: smblpcontainerregistry
  IMAGE_NAME: smb-api

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    steps:
      - uses: actions/checkout@v4

      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Install Azure Container Apps extension
        run: az extension add --name containerapp --upgrade

      - name: Build and push image to ACR (remote)
        run: |
          set -euo pipefail
          echo "Building $ACR_NAME.azurecr.io/$IMAGE_NAME:${{ github.sha }} from Backend/Dockerfile"
          az acr build \
            -r "$ACR_NAME" \
            -t "$ACR_NAME.azurecr.io/$IMAGE_NAME:${{ github.sha }}" \
            -f Backend/Dockerfile Backend

      - name: Deploy image & set env vars (direct update)
        run: |
          set -euo pipefail
          echo "Deploying image via az containerapp update (secret refs + env)"
          az containerapp update \
            -g "$AZURE_RESOURCE_GROUP" -n "$CONTAINERAPP_NAME" \
            --image "${{ env.ACR_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}:${{ github.sha }}" \
            --set-env-vars \
              SECRET_KEY=secretref:secretkey \
              JWT_SECRET=secretref:jwtsecretkey \
              RESET_SECRET=secretref:resetsecretkey \
              DATABASE_URL=${{ secrets.CA_DATABASE_URL }} \
              ALLOWED_ORIGINS=${{ secrets.CA_ALLOWED_ORIGINS }} \
              FRONTEND_URL=${{ secrets.CA_FRONTEND_URL }} \
              ENVIRONMENT=production \
              SENTRY_DSN=${{ secrets.CA_SENTRY_DSN }} \
              YOCO_SECRET_KEY=${{ secrets.CA_YOCO_SECRET_KEY }} \
              YOCO_WEBHOOK_SECRET=${{ secrets.CA_YOCO_WEBHOOK_SECRET }} \
              FIREBASE_CREDENTIALS_JSON=${{ secrets.CA_FIREBASE_CREDENTIALS_JSON }}
          echo "Container App update submitted"

      - name: Wait for new revision (provisioning + replica)
        run: |
          set -euo pipefail
          echo "Waiting for new revision to reach Succeeded with >=1 replica"
          start=$SECONDS
          timeout=180
          rev=$(az containerapp show -g "$AZURE_RESOURCE_GROUP" -n "$CONTAINERAPP_NAME" --query properties.latestRevisionName -o tsv)
          echo "Latest revision: $rev"
          while true; do
            state=$(az containerapp revision show -g "$AZURE_RESOURCE_GROUP" -n "$CONTAINERAPP_NAME" --revision "$rev" --query properties.provisioningState -o tsv 2>/dev/null || echo unknown)
            replicas=$(az containerapp revision show -g "$AZURE_RESOURCE_GROUP" -n "$CONTAINERAPP_NAME" --revision "$rev" --query "length(properties.instances)" -o tsv 2>/dev/null || echo 0)
            echo "Revision $rev state=$state replicas=$replicas"
            if [ "$state" = "Succeeded" ] && [ "$replicas" -ge 1 ]; then
              echo "Revision $rev is running"
              echo "LATEST_REVISION=$rev" >> $GITHUB_ENV
              break
            fi
            if [ $(( SECONDS - start )) -gt $timeout ]; then
              echo "Timed out waiting for revision $rev" >&2
              exit 1
            fi
            sleep 6
          done

      - name: Output app URL
        run: |
          fqdn=$(az containerapp show -g "$AZURE_RESOURCE_GROUP" -n "$CONTAINERAPP_NAME" --query properties.configuration.ingress.fqdn -o tsv)
          echo "API URL: https://$fqdn"
          echo "FQDN=$fqdn" >> $GITHUB_ENV

      - name: Run Alembic migrations (optional)
        if: ${{ inputs.run_migrations == 'true' }}
        run: |
          echo "Running Alembic migrations inside container app..."
          az containerapp exec -g "$AZURE_RESOURCE_GROUP" -n "$CONTAINERAPP_NAME" --command "alembic -c alembic.ini upgrade head"
          echo "Migrations complete"

      - name: Health check (ready-lite + diagnostics)
        run: |
          set -euo pipefail
          echo "Waiting for internal /health/ready-lite via az containerapp exec (ringfence-safe) ..."
          retry_seconds='${{ inputs.health_retry_seconds }}'
          if [ -z "$retry_seconds" ]; then retry_seconds=90; fi
          if ! echo "$retry_seconds" | grep -Eq '^[0-9]+$'; then retry_seconds=90; fi
          end=$(( SECONDS + retry_seconds ))
          ok=false
          attempt=0
          while [ $SECONDS -lt $end ]; do
            attempt=$((attempt+1))
            # Run curl inside the running container to avoid public ingress/ringfence
            if az containerapp exec -g "$AZURE_RESOURCE_GROUP" -n "$CONTAINERAPP_NAME" \
              --command "sh -lc 'code=\$(curl -s -o /dev/null -w \"%{http_code}\" http://localhost:8000/health/ready-lite || echo 000); echo ready-lite:\ $code; [ \"$code\" = 200 ]'"; then
              ok=true
              break
            fi
            if [ $attempt -eq 1 ]; then
              echo "First attempt failed; container may still be starting. Retrying..."
            fi
            sleep 5
          done
          if [ "$ok" = false ]; then
            echo "ready-lite check (internal) failed" >&2; exit 1; fi
          echo "ready-lite OK (internal)"
          # Optional: surface deep readiness and startup via internal checks (non-fatal)
          az containerapp exec -g "$AZURE_RESOURCE_GROUP" -n "$CONTAINERAPP_NAME" \
            --command "sh -lc 'curl -s -o /dev/null -w \"deep=%{http_code}\n\" http://localhost:8000/health/ready || true'" || true
          az containerapp exec -g "$AZURE_RESOURCE_GROUP" -n "$CONTAINERAPP_NAME" \
            --command "sh -lc 'curl -s -o /dev/null -w \"startup=%{http_code}\n\" http://localhost:8000/health/startup || true'" || true

      - name: Post-deploy smoke tests
        run: |
          set -euo pipefail
          chmod +x scripts/post_deploy_smoke.sh || true
          PUBLIC_API_URL='${{ secrets.CA_PUBLIC_API_URL }}'
          if [ -n "$PUBLIC_API_URL" ]; then
            echo "Running external smoke tests against CA_PUBLIC_API_URL=$PUBLIC_API_URL"
            export API_BASE="$PUBLIC_API_URL"
            ./scripts/post_deploy_smoke.sh
            echo "Smoke tests passed"
          else
            echo "No CA_PUBLIC_API_URL provided; skipping external smoke tests due to backend ringfencing."
          fi
