name: Deploy API (Azure Container Apps)

permissions:
  contents: read
  id-token: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

on:
  push:
    branches: [ main ]
    paths:
      - 'Backend/**'
      - '.github/workflows/backend-azure-containerapps.yml'
  workflow_dispatch:
    inputs:
      run_migrations:
        description: "Run Alembic upgrade head after deploy (true/false)"
        required: false
        default: 'false'
      health_retry_seconds:
        description: "Max seconds to wait for /health/ready=200"
        required: false
        default: '90'

env:
  AZURE_RESOURCE_GROUP: SMB-Loyalty-Group
  CONTAINERAPP_NAME: apismbloyaltyapp
  ACR_NAME: smblpcontainerregistry
  IMAGE_NAME: smb-api

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    steps:
      - uses: actions/checkout@v4

      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Install Azure Container Apps extension
        run: az extension add --name containerapp --upgrade

      - name: Build and push image to ACR (remote)
        run: |
          set -euo pipefail
          echo "Building $ACR_NAME.azurecr.io/$IMAGE_NAME:${{ github.sha }} from Backend/Dockerfile"
          az acr build \
            -r "$ACR_NAME" \
            -t "$ACR_NAME.azurecr.io/$IMAGE_NAME:${{ github.sha }}" \
            -f Backend/Dockerfile Backend

      - name: Deploy image & set env vars (direct update)
        run: |
          set -euo pipefail
          echo "Deploying image via az containerapp update (secret refs + env)"
          az containerapp update \
            -g "$AZURE_RESOURCE_GROUP" -n "$CONTAINERAPP_NAME" \
            --image "${{ env.ACR_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}:${{ github.sha }}" \
            --set-env-vars \
              SECRET_KEY=secretref:secretkey \
              JWT_SECRET=secretref:jwtsecretkey \
              RESET_SECRET=secretref:resetsecretkey \
              DATABASE_URL=${{ secrets.CA_DATABASE_URL }} \
              ALLOWED_ORIGINS=${{ secrets.CA_ALLOWED_ORIGINS }} \
              FRONTEND_URL=${{ secrets.CA_FRONTEND_URL }} \
              ENVIRONMENT=production \
              SENTRY_DSN=${{ secrets.CA_SENTRY_DSN }} \
              YOCO_SECRET_KEY=${{ secrets.CA_YOCO_SECRET_KEY }} \
              YOCO_WEBHOOK_SECRET=${{ secrets.CA_YOCO_WEBHOOK_SECRET }} \
              FIREBASE_CREDENTIALS_JSON=${{ secrets.CA_FIREBASE_CREDENTIALS_JSON }}
          echo "Container App update submitted"

      - name: Wait for new revision (provisioning + replica)
        run: |
          set -euo pipefail
          echo "Waiting for new revision to reach Succeeded with >=1 replica"
          start=$SECONDS
          timeout=180
          rev=$(az containerapp show -g "$AZURE_RESOURCE_GROUP" -n "$CONTAINERAPP_NAME" --query properties.latestRevisionName -o tsv)
          echo "Latest revision: $rev"
          while true; do
            state=$(az containerapp revision show -g "$AZURE_RESOURCE_GROUP" -n "$CONTAINERAPP_NAME" --revision "$rev" --query properties.provisioningState -o tsv 2>/dev/null || echo unknown)
            replicas=$(az containerapp revision show -g "$AZURE_RESOURCE_GROUP" -n "$CONTAINERAPP_NAME" --revision "$rev" --query "length(properties.instances)" -o tsv 2>/dev/null || echo 0)
            echo "Revision $rev state=$state replicas=$replicas"
            if [ "$state" = "Succeeded" ] && [ "$replicas" -ge 1 ]; then
              echo "Revision $rev is running"
              echo "LATEST_REVISION=$rev" >> $GITHUB_ENV
              break
            fi
            if [ $(( SECONDS - start )) -gt $timeout ]; then
              echo "Timed out waiting for revision $rev" >&2
              exit 1
            fi
            sleep 6
          done

      - name: Output app URL
        run: |
          fqdn=$(az containerapp show -g "$AZURE_RESOURCE_GROUP" -n "$CONTAINERAPP_NAME" --query properties.configuration.ingress.fqdn -o tsv)
          echo "API URL: https://$fqdn"
          echo "FQDN=$fqdn" >> $GITHUB_ENV

      - name: Run Alembic migrations (optional)
        if: ${{ inputs.run_migrations == 'true' }}
        run: |
          echo "Running Alembic migrations inside container app..."
          az containerapp exec -g "$AZURE_RESOURCE_GROUP" -n "$CONTAINERAPP_NAME" --command "alembic -c alembic.ini upgrade head"
          echo "Migrations complete"

      - name: Health check (ready-lite + diagnostics)
        run: |
          set -euo pipefail
          fqdn=$(az containerapp show -g "$AZURE_RESOURCE_GROUP" -n "$CONTAINERAPP_NAME" --query properties.configuration.ingress.fqdn -o tsv)
          echo "Waiting for /health/ready-lite ..."
          # Determine timeout seconds: prefer explicit workflow dispatch input, else default 90
          retry_seconds='${{ inputs.health_retry_seconds }}'
          if [ -z "$retry_seconds" ]; then retry_seconds=90; fi
          if ! echo "$retry_seconds" | grep -Eq '^[0-9]+$'; then retry_seconds=90; fi
          end=$(( SECONDS + retry_seconds ))
          ok=false
          attempt=0
          while [ $SECONDS -lt $end ]; do
            attempt=$((attempt+1))
            tmp_headers=$(mktemp)
            tmp_body=$(mktemp)
            # Capture headers + body separately (curl doesn't have a simple split; use -D for headers)
            code=$(curl -s -D "$tmp_headers" -o "$tmp_body" -w '%{http_code}' "https://$fqdn/health/ready-lite" 2>/dev/null || echo 000)
            echo "ready-lite: $code"
            if [ "$code" = "200" ]; then
              ok=true
              rm -f "$tmp_headers" "$tmp_body"
              break
            fi
            if [ $attempt -eq 1 ]; then
              echo "--- First attempt headers ---"; cat "$tmp_headers" || true; echo "--- body ---"; cat "$tmp_body" || true; echo "--- end ---"
            fi
            if [ "$code" = "401" ]; then
              echo "Hint: 401 indicates request passed through auth/tenant logic. Verify middleware exemption for /health/* present in deployed image and traffic directed to new revision."
            fi
            rm -f "$tmp_headers" "$tmp_body"
            sleep 5
          done
          if [ "$ok" = false ]; then
            echo "ready-lite check failed" >&2; exit 1; fi
          echo "ready-lite OK"
          deep=$(curl -s -o /dev/null -w '%{http_code}' "https://$fqdn/health/ready" || echo 000)
            echo "deep readiness: $deep"
          startup=$(curl -s -o /dev/null -w '%{http_code}' "https://$fqdn/health/startup" || echo 000)
            echo "startup: $startup"

      - name: Post-deploy smoke tests
        run: |
          set -euo pipefail
          chmod +x scripts/post_deploy_smoke.sh || true
          fqdn=$(az containerapp show -g "$AZURE_RESOURCE_GROUP" -n "$CONTAINERAPP_NAME" --query properties.configuration.ingress.fqdn -o tsv)
          export API_BASE="https://$fqdn"
          ./scripts/post_deploy_smoke.sh
          echo "Smoke tests passed"
